# 1st
(1回目の誤答)
```python
class Solution(object):
    def isValid(self, s):
        """
        :type s: str
        :rtype: bool
        """
        brackets = {'(': ')', '{': '}', '[' : ']'}
        close_brackets = {')','}',']'}
        correct_s = {}
        for i in range(len(s)):
            # 開かっこかどうか
            if s[i] in brackets:
                correct_s[i] = s[i]
                
            # 閉じ括弧では何もしない
        # open_orderに開き括弧の種類と配置順が入っている
        {0:(,2:[)}
        for i in range(len(s)):
            if i in correct_s:
                # 開括弧の次→閉じ括弧or開括弧の次に開括弧があれば最後の開き括弧の次が閉じ括弧で閉じ括弧は最後の開き括弧に対応する。
                #　考慮する条件が多すぎるのでもっとシンプルな対応を確認する数え方がないか

                # correct_sとsを比較する。

        [()]
        0 1 2
        

```

・後方の開かっこから順に、その開きかっこに対応する閉じ括弧が入っていればOK→スタックの問題
・正直、close_to_openにする理由がよくわからなかった。過去のレビューを見てもopen_to_closeが推奨されているので、こちらで回答する。
・open_to_closeの答えはまだ見ていない。


(2回目で正答)
```python
class Solution(object):
    def isValid(self, s):
        """
        :type s: str
        :rtype: bool
        """
        open_brackets_stack = []
        open_to_close = {'(': ')', '{': '}', '[' : ']'}
        correct_s = ''
        for char in s:
            if char in open_to_close:
                open_brackets_stack.append(char)
                correct_s = correct_s + char
            else:
                
                correct_s = correct_s + open_to_close[open_brackets_stack.pop()] if open_brackets_stack else "#" 
        return s == correct_s and len(open_brackets_stack) == 0

```

