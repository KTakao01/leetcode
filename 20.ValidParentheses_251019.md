# 1st
(1回目の誤答)
```python
class Solution(object):
    def isValid(self, s):
        """
        :type s: str
        :rtype: bool
        """
        brackets = {'(': ')', '{': '}', '[' : ']'}
        close_brackets = {')','}',']'}
        correct_s = {}
        for i in range(len(s)):
            # 開かっこかどうか
            if s[i] in brackets:
                correct_s[i] = s[i]
                
            # 閉じ括弧では何もしない
        # open_orderに開き括弧の種類と配置順が入っている
        {0:(,2:[)}
        for i in range(len(s)):
            if i in correct_s:
                # 開括弧の次→閉じ括弧or開括弧の次に開括弧があれば最後の開き括弧の次が閉じ括弧で閉じ括弧は最後の開き括弧に対応する。
                #　考慮する条件が多すぎるのでもっとシンプルな対応を確認する数え方がないか

                # correct_sとsを比較する。

        [()]
        0 1 2
        

```

・後方の開かっこから順に、その開きかっこに対応する閉じ括弧が入っていればOK→スタックの問題
・正直、close_to_openにする理由がよくわからなかった。過去のレビューを見てもopen_to_closeが推奨されているので、こちらで回答する。
・open_to_closeの答えはまだ見ていない。


(2回目で正答、leetcodeではOK、AIではNG)
```python
class Solution(object):
    def isValid(self, s):
        """
        :type s: str
        :rtype: bool
        """
        open_brackets_stack = []
        open_to_close = {'(': ')', '{': '}', '[' : ']'}
        correct_s = ''
        for char in s:
            if char in open_to_close:
                open_brackets_stack.append(char)
                correct_s = correct_s + char
            else:
                correct_s = correct_s + open_to_close[open_brackets_stack.pop()] if open_brackets_stack else "#" 
        return s == correct_s and len(open_brackets_stack) == 0

```

・上記回答はAIレビューでNG箇所があったため検討
・NGの内容は以下の通り。
```python
# Pythonの三項演算子は「value_if_true if condition else value_if_false」で評価されるため、現在のコードは以下のように動作します：

# 現在のコード (問題あり)
correct_s = correct_s + open_to_close[open_brackets_stack.pop()] if open_brackets_stack else "#"
# 解析結果:
correct_s = (correct_s + open_to_close[open_brackets_stack.pop()]) if open_brackets_stack else "#"
# スタックが空の場合: correct_s = "#" (置き換え、追記ではない)
# 最終的にはs == correct_sの比較で正しい結果が得られていますが、これは偶然に頼っています。意図をより明確にするため、括弧で優先度を明示することをお勧めします：
```

(2回目の回答の修正)
```python
class Solution(object):
    def isValid(self, s):
        """
        :type s: str
        :rtype: bool
        """
        open_brackets_stack = []
        open_to_close = {'(': ')', '{': '}', '[' : ']'}
        correct_s = ''
        for char in s:
            if char in open_to_close:
                open_brackets_stack.append(char)
                correct_s = correct_s + char
            else:
                correct_s = correct_s + (open_to_close[open_brackets_stack.pop()] if open_brackets_stack else "#" )
        return s == correct_s and len(open_brackets_stack) == 0
```


他の方の回答を見る
- [プッシュダウンオートマトン](https://github.com/h1rosaka/arai60/pull/8/files)
・リンクのプッシュダウンオートマトンが気になるので後で見る。


## 2nd　(20251101)

(解答：これまでの解答のコードの可読性を上げた。正しい文字列になっているかチェックする方式)
``` python
class Solution(object):
    def isValid(self, s):
        """
        :type s: str
        :rtype: bool
        """
        open_brackets_stack = []
        open_to_close = {'(': ')', '{': '}', '[' : ']'}
        correct_s = ''
        for char in s:
            if char in open_to_close:
                close_brackets = open_to_close[char]
                open_brackets_stack.append(close_brackets)
                correct_s = correct_s + char
            else:                
                correct_s = correct_s + open_brackets_stack.pop() if open_brackets_stack else "#" 
        return s == correct_s and len(open_brackets_stack) == 0
```

以下、レビュー対応
その1:アプローチを変える
(別解:不正な値を検出して検出されなかったパターンを正とする方式)
・正答判定を出すまで1時間前後かかってしまった。
```python
class Solution(object):
    def isValid(self, s):
        """
        :type s: str
        :rtype: bool
        """
        open_brackets_stack = []
        open_to_close = {'(': ')', '{': '}', '[' : ']'}
        for char in s:
            if char in open_to_close:#charが開括弧の場合
                close_brackets = open_to_close[char]
                open_brackets_stack.append(close_brackets)
            else: #charが閉括弧の場合
                if len(open_brackets_stack) != 0:  # 開括弧と閉括弧の混在している場合
                    if open_brackets_stack.pop() != char: #不正ペアの検知
                        return False
                    if len(s) % 2 == 1: #ペアを数的に組めない余りがいるパターン”例：({}”を除外
                        return False 
                else: # 閉じ括弧のみの場合
                    return False
        if len(open_brackets_stack) == len(s): return False #開括弧だけの場合を除外
        if len(open_brackets_stack) != 0: return False #開括弧と閉括弧の混在していて、開括弧と閉括弧の数が等しくない場合"[]]]"を除外
        return True
```


別解の方がパフォーマンスが良かった。3ms。これまでの解答は10ms。
旧解答は最後まで処理をしないと判断できないからパフォーマンスが悪いのかもしれません。
またpython3の文字列はイミュータブルで、結合するたびに旧文字列と追加したい文字列をコピーして新文字列として結合するので遅い。


その2：Googleのコーディング規約を参考にする。1行を短くする。
(コードの可読性:)
```python
class Solution:
    def isValid(self, s):
        """
        :type s: str
        :rtype: bool
        """
        open_brackets_stack = []
        open_to_close = {'(': ')', '{': '}', '[' : ']'}
        correct_s = ''
        for char in s:
            if char in open_to_close:
                close_brackets = open_to_close[char]
                open_brackets_stack.append(close_brackets)
                correct_s = correct_s + char
            else:          
                if open_brackets_stack:      
                    correct_s = correct_s + open_brackets_stack.pop()  
                else: "#" 
        return s == correct_s and not open_brackets_stack

```

（別解をよりシンプルにする）
・対応する閉じ括弧と開括弧の種類が異なる
・閉じ括弧に対応する開括弧がないはNG
・開括弧が閉じ括弧より多いはNG

```python
class Solution:
    def isValid(self, s):
        """
        :type s: str
        :rtype: bool
        """
        open_brackets = []
        open_to_close = {'(': ')', '{': '}', '[' : ']'}
        for char in s:
            if char in open_to_close:
                open_brackets.append(char)
            else:          
                if not open_brackets:
                    return False
                if open_to_close[open_brackets.pop()] != char:
                    return False
        return not open_brackets
```

```markdown
ループを1文字読むごとに「これまで読んだ部分は正しい括弧列の“途中状態”である」ことを保つ
これが「不変条件 (invariant)」ってやつです。
もうちょっと具体的にするとこうなります：
いままで読んだところまでで、開き括弧と閉じ括弧の順番はおかしくない
いままで読んだところまでで、開きすぎてる分だけスタックに残ってる
おかしな閉じ括弧が来たらその場でFalseを返す
この“不変条件を保ちながら進む”って考えると、ループの中でやることは自然に2パターンに分かれます。
開き括弧なら「後で閉じる必要があるよ」としてスタックに積む
閉じ括弧なら「さっき積んだやつを今閉じるよ」としてスタックから1個取って対応を確認する
これ以外、要らないんですよ。だからシンプル。
```