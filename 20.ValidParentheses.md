```python
# 20. Valid Parentheses
# Easy
# Topics
# Companies
# Hint
# Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.

# An input string is valid if:

# Open brackets must be closed by the same type of brackets.
# Open brackets must be closed in the correct order.
# Every close bracket has a corresponding open bracket of the same type.
```

# 自身の回答
## 1st

誤答１回目：ユースケース漏れ
・入力文字列とそこから想定される正しい文字列を比較して、一致していれば入力値が適切、不一致ならば入力値が不適切とする。
・先に開き括弧が来て、後に閉じ括弧が来る。→閉じ括弧が先に来るときは、false
・開き括弧の文字列とセットの閉じ括弧が来る。
→開き括弧に対する閉じ括弧のハッシュマップを作成して、開き括弧が入力されていることをチェックした後に次の文字列があるときは、対応する閉じ括弧を入力するようにする。


``` python
class Solution:
    def isValid(self, s: str) -> bool:

        # ({)} is true?
        # If you don’t care about the order in which the brackets are closed, as in the example above, you can simply run a loop.
        hashmap = {"(":")","{":"}","[":"]"}
        openS = []
        closeS = []
        for i in range(len(s)) :         
            if s[i] == "(" or s[i] == "{" or s[i] == "[":
                openS.append(s[i])
                closeS.append(hashmap[s[i]])
            else:
                # 組み合わせとして先に閉じ括弧が来るときはfalse
                if closeS == []: return false
                openS.append(closeS.pop())
        return s == ''.join(openS)
```


```python
Input
s ="["

Use Testcase
Output
true
Expected
false
```

考慮漏れ
・開き括弧だけが入力文字列として存在する場合でもTrueになる。


誤答２回目：ユースケース漏れ
追加仕様
・開き括弧だけ単独で存在していて次の文字列がない場合、適切な文字列扱いとなるので、模範文字列が奇数の場合はfalseとする。

```python
class Solution:
    def isValid(self, s: str) -> bool:

        # ({)} is true?
        # If you don’t care about the order in which the brackets are closed, as in the example above, you can simply run a loop.
        hashmap = {"(":")","{":"}","[":"]"}
        openS = []
        closeS = []
        for i in range(len(s)) :         
            if s[i] == "(" or s[i] == "{" or s[i] == "[":
                openS.append(s[i])
                closeS.append(hashmap[s[i]])
            else:
                # 組み合わせとして先に閉じ括弧が来るときはfalse
                if closeS == []: return False
                openS.append(closeS.pop())
        if len(openS) % 2 == 1 : 
            return False
        return s == ''.join(openS)
```

``` python
Input
s ="(("

Use Testcase
Output
true
Expected
false
```

考慮漏れ：偶数文字数であっても開き括弧だけが連続して単独に存在するケースがある。


正答１回目：
・奇数文字列かつ開き括弧に対応する閉じ括弧を文字列に使っていない場合falseとすることで、
開き括弧だけの入力文字列を文字数にかかわらずfalseにできる。


```python
class Solution:
    def isValid(self, s: str) -> bool:

        # ({)} is true?
        # If you don’t care about the order in which the brackets are closed, as in the example above, you can simply run a loop.
        hashmap = {"(":")","{":"}","[":"]"}
        openS = []
        closeS = []
        for i in range(len(s)) :         
            if s[i] == "(" or s[i] == "{" or s[i] == "[":
                openS.append(s[i])
                closeS.append(hashmap[s[i]])
            else:
                # 組み合わせとして先に閉じ括弧が来るときはfalse
                if closeS == []: return False
                openS.append(closeS.pop())
        if len(openS) % 2 == 1 or len(closeS) != 0 : 
            return False
        return s == ''.join(openS)
```

## 2nd
コードを見やすくする
・変数名が指示する内容を表すように修正


```python
class Solution:
    def isValid(self, s: str) -> bool:

        # ({)} is true?
        # If you don’t care about the order in which the brackets are closed, as in the example above, you can simply run a loop.
        brackets = {"(":")","{":"}","[":"]"}
        ideal_strings = []
        corresponding_close_brackets = []
        for i in range(len(s)) :         
            if s[i] == "(" or s[i] == "{" or s[i] == "[":
                ideal_strings.append(s[i])
                corresponding_close_brackets.append(brackets[s[i]])
            else:
                # 組み合わせとして先に閉じ括弧が来るときはfalse
                if corresponding_close_brackets == []: return False
                ideal_strings.append(corresponding_close_brackets.pop())
        if len(openS) % 2 == 1 or len(corresponding_close_brackets) != 0 : 
            return False
        return s == ''.join(openS)
```


# 模範回答
## 1st
・模範回答が0msで自前の回答が1msで模範回答の方が速かった。
原因は主に２つ。
・時間計算量：処理の最後に理想的な文字列と実際の文字列を比較している
・空間計算量：リストを２つ使用および１つのリストのメモリ占有がそもそも大きいと
詳細は以下。

```python
両方のプログラムを分析し、時間・空間計算量を比較してみましょう。
時間計算量
模範回答（0ms）:

文字列sを1回だけ走査（O(n)）
スタック操作（push/pop）は定数時間（O(1)）
マッピング検索も定数時間（O(1)）
全体：O(n)

自前の回答（1ms）:

文字列sを1回だけ走査（O(n)）
ideal_stringsとcorresponding_close_bracketsへの追加/削除操作（O(1)）
最後にs == ''.join(openS)で文字列結合と比較（O(n)）
全体：O(n)

時間計算量的には両方ともO(n)ですが、自前の回答の最後に''.join(openS)という操作があり、これは追加のO(n)時間を要します。
空間計算量
模範回答：

スタック：最悪の場合O(n)（全ての文字が開き括弧の場合）
マッピング辞書：定数サイズO(1)
全体：O(n)

自前の回答：

ideal_strings：最悪の場合O(n)
corresponding_close_brackets：最悪の場合O(n)
全体：O(n)

ただし、自前の回答は2つのリストを使用するため、実質的に2倍のメモリを使用します。
速度の差の理由

余分な操作: 自前の回答は''.join(openS)で文字列結合を行い、元の文字列と比較しています。これは不要なO(n)の操作です。
2つのリストの使用: 自前の回答はideal_stringsとcorresponding_close_bracketsという2つのリストを管理しています。これに対し、模範回答はスタック1つだけです。
アルゴリズムの効率: 模範回答は必要最小限の操作だけを行い、閉じ括弧が来たときにすぐに検証します。自前の回答は閉じ括弧が来たときに対応する開き括弧をideal_stringsに追加し、最後に全体を検証します。
コードの問題点: 自前の回答にはopenSという変数が参照されていますが、定義されていません。おそらくideal_stringsの間違いです。また、({)}のようなケースをTrue扱いするコメントがありますが、実際のコードの結果はFalseになります。

まとめ
模範回答の方が速いのは主に以下の理由によります：

より少ないメモリ使用量（スタック1つのみ）
余分な文字列操作の欠如（join不要）
より効率的なアルゴリズム設計（閉じ括弧が来たときに即検証）

自前の回答は同じ計算量を持ちますが、定数倍の違いが実行時間の差として現れています。また、コード内のエラーや余分な操作も実行時間に影響しています。
```



# 2nd


# 3rd